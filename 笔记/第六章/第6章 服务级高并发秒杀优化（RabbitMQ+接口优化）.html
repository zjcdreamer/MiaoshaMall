<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602051 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 14pt;
    }
  </style>
</head>
<body>
<a name="2423"/>

<div>
<span><div><div><div><div><span style="font-size: 24pt; font-weight: bold;">一、集成RabbitMQ</span></div><hr/><div>1）添加依赖</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;dependency&gt;  </div><div>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  </div><div>   &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;  </div><div>&lt;/dependency&gt;</div></div><div><br/></div><div>2）写配置</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#rabbitmq</div><div>spring.rabbitmq.host=10.110.3.62</div><div>spring.rabbitmq.port=5672</div><div>spring.rabbitmq.username=guest</div><div>spring.rabbitmq.password=guest</div><div>spring.rabbitmq.virtual-host=/</div><div>#消费者数量</div><div>spring.rabbitmq.listener.simple.concurrency= 10</div><div>spring.rabbitmq.listener.simple.max-concurrency= 10</div><div>#消费者每次从队列获取的消息数量</div><div>spring.rabbitmq.listener.simple.prefetch= 1</div><div>#消费者自动启动</div><div>spring.rabbitmq.listener.simple.auto-startup=true</div><div>#消费失败，自动重新入队</div><div>spring.rabbitmq.listener.simple.default-requeue-rejected= true</div><div>#启用发送重试</div><div>spring.rabbitmq.template.retry.enabled=true</div><div>spring.rabbitmq.template.retry.initial-interval=1000</div><div>spring.rabbitmq.template.retry.max-attempts=3</div><div>spring.rabbitmq.template.retry.max-interval=10000</div><div>spring.rabbitmq.template.retry.multiplier=1.0</div></div><div><br/></div><div>3）因为使用的账户是guest。在RabbitMQ中guest默认是不能远程连接服务器的，所以需要在rabbitmq的目录下的etc/rabbitmq中新建一个rabbitmq.config，里面的配置写：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>[{rabbit,[{loopback_users,[]}]}].</div></div><div><br/></div><div>4）写一个队列的配置类，生成一个队列</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>package com.imooc.miaosha.rabbitmq;</div><div><br/></div><div><br/></div><div>import org.springframework.amqp.core.Queue;</div><div>import org.springframework.context.annotation.Bean;</div><div>import org.springframework.context.annotation.Configuration;</div><div><br/></div><div><br/></div><div><b><font style="font-size: 10pt;">@Configuration</font></b></div><div>public class MQConfig {</div><div><br/></div><div><br/></div><div>    public static final String QUEUE = &quot;RabbitMQ&quot;;</div><div><br/></div><div><br/></div><div>    <b>@Bean</b></div><div><b>    public Queue queue() {</b></div><div><b>        return new Queue(QUEUE, true);</b></div><div><b>    }</b></div><div>}</div></div><div><br/></div><div>5）编写一个消息的发送者（通过AmqpTemplate的方法来发送消息）</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>package com.imooc.miaosha.rabbitmq;</div><div><br/></div><div><br/></div><div>import com.imooc.miaosha.redis.RedisService;</div><div>import org.slf4j.Logger;</div><div>import org.slf4j.LoggerFactory;</div><div>import org.springframework.amqp.core.AmqpTemplate;</div><div>import org.springframework.beans.factory.annotation.Autowired;</div><div>import org.springframework.stereotype.Service;</div><div><br/></div><div><br/></div><div><b>@Service</b></div><div>public class MQSender {</div><div><br/></div><div><br/></div><div>    private static Logger log = LoggerFactory.getLogger(MQSender.class);</div><div><br/></div><div><br/></div><div>    <b><font style="font-size: 10pt;">@Autowired</font></b></div><div><b><font style="font-size: 10pt;">    AmqpTemplate amqpTemplate</font></b>;</div><div><br/></div><div><br/></div><div>    public void send(Object mm){</div><div>        String msg = RedisService.beanToString(mm);</div><div>        log.info(&quot;send message:&quot;+msg);</div><div>        <b>amqpTemplate.convertAndSend(MQConfig.QUEUE, msg); //写出发送到的队列和携带的信息</b></div><div>    }</div><div>}</div></div><div><br/></div><div>6）编写一个消息的接收者（通过@RabbitListener来监听队列，从而接收到消息）</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>package com.imooc.miaosha.rabbitmq;</div><div><br/></div><div><br/></div><div>import org.slf4j.LoggerFactory;</div><div>import org.springframework.amqp.rabbit.annotation.RabbitListener;</div><div>import org.springframework.stereotype.Service;</div><div>import org.slf4j.Logger;</div><div>import org.slf4j.LoggerFactory;</div><div><br/></div><div><br/></div><div><b>@Service</b></div><div>public class MQReceiver {</div><div>    public static Logger log = LoggerFactory.getLogger(MQReceiver.class);</div><div><br/></div><div><br/></div><div>    @RabbitListener(queues=MQConfig.QUEUE)</div><div>    public void receive(String msg){</div><div>        log.info(&quot;receive message:&quot;+msg);</div><div>    }</div><div>}</div></div><div><br/></div><div>7）在Controller层写一个方法，来进行检验</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@ResponseBody</div><div>@RequestMapping(&quot;/mq&quot;)</div><div>public Result&lt;String&gt; mq(){</div><div>    mqSender.send(&quot;hello,mq&quot;);</div><div>    return Result.success(&quot;ok&quot;);</div><div>}</div></div><div><br/></div><div><br/></div><div><span style="font-size: 24pt; font-weight: bold;">二、RabbitMQ交换机四种模式</span></div></div><hr/><div><span style="font-weight: bold;">direct模式</span>：需要发送数据的routingkey与队列绑定在交换机上的bindingkey完全相同才可以</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><b><font style="font-size: 10pt;">MQConfig类</font></b></div><div>public static final String QUEUE = &quot;RabbitMQ&quot;;</div><div><br/></div><div>@Bean</div><div>public Queue queue() {</div><div>    return new Queue(QUEUE, true);</div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div><b><font style="font-size: 11pt;">MQSender类</font></b></div><div><br/></div><div>private static Logger log = LoggerFactory.getLogger(MQSender.class);</div><div><br/></div><div>@Autowired</div><div>AmqpTemplate amqpTemplate;</div><div><br/></div><div>public void send(Object mm){</div><div>    String msg = RedisService.beanToString(mm);</div><div>    log.info(&quot;send message:&quot;+msg);</div><div>    amqpTemplate.convertAndSend(MQConfig.QUEUE, msg);</div><div>}</div><div><br/></div><div><b><font style="font-size: 11pt;">MQReceiver类</font></b></div><div>@RabbitListener(queues=MQConfig.QUEUE)</div><div>public void receive(String msg){</div><div>    log.info(&quot;receive message:&quot;+msg);</div><div>}</div></div><div>结果：<img src="第6章 服务级高并发秒杀优化（RabbitMQ+接口优化）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="font-weight: bold;">topic模式</span>：发送数据的routingkey与队列绑定在交换机上的bindingkey的格式相同即可，可以使用占位符</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><b><font style="font-size: 11pt;">MQConfig类</font></b></div><div>public static final String TOPIC_QUEUE1 = &quot;topqueue1&quot;;</div><div>public static final String TOPIC_QUEUE2 = &quot;topqueue2&quot;;</div><div>public static final String TOPIC_EXCHANGE = &quot;topicexchange&quot;;</div><div><br/></div><div>@Bean</div><div>public Queue topicQueue1(){</div><div>    return new Queue(TOPIC_QUEUE1, true);</div><div>}</div><div><br/></div><div>@Bean</div><div>public Queue topicQueue2(){</div><div>    return new Queue(TOPIC_QUEUE2, true);</div><div>}</div><div><br/></div><div>@Bean</div><div>public TopicExchange topicExchange(){</div><div>    return new TopicExchange(TOPIC_EXCHANGE);</div><div>}</div><div><br/></div><div>@Bean</div><div>public Binding topicBinding1(){</div><div>    return BindingBuilder.bind(topicQueue1()).to(topicExchange()).with(&quot;topic.key1&quot;);</div><div>}</div><div><br/></div><div>@Bean</div><div>public Binding topicBinding2(){</div><div>    return BindingBuilder.bind(topicQueue2()).to(topicExchange()).with(&quot;topic.#&quot;);</div><div>}</div><div><br/></div><div><b><font style="font-size: 11pt;">MQSender类：</font></b></div><div>public void topicSend(Object mm){</div><div>    String msg = RedisService.beanToString(mm);</div><div>    log.info(&quot;send message:&quot;+msg);</div><div>    amqpTemplate.convertAndSend(MQConfig.TOPIC_EXCHANGE, &quot;topic.key1&quot;, msg+&quot;1&quot;);</div><div>    amqpTemplate.convertAndSend(MQConfig.TOPIC_EXCHANGE, &quot;topic.key2&quot;, msg+&quot;2&quot;);</div><div>}</div><div><br/></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco;"><b><font style="font-size: 11pt;">MQSender类：</font></b></span></div><div>@RabbitListener(queues=MQConfig.TOPIC_QUEUE1)</div><div>public void topicReceive1(String msg){</div><div>    log.info(&quot;TOPIC_QUEUE1 message:&quot;+msg);</div><div>}</div><div><br/></div><div>@RabbitListener(queues=MQConfig.TOPIC_QUEUE2)</div><div>public void topicReceive2(String msg){</div><div>    log.info(&quot;TOPIC_QUEUE2 message:&quot;+msg);</div><div>}</div><div><br/></div><div><b><font style="font-size: 11pt;">SampleController类：</font></b></div><div>@ResponseBody</div><div>@RequestMapping(&quot;/mq/topic&quot;)</div><div>public Result&lt;String&gt; mqTopic(){</div><div>    mqSender.topicSend(&quot;hello,mq&quot;);</div><div>    return Result.success(&quot;ok&quot;);</div><div>}</div></div><div>结果：</div><div><img src="第6章 服务级高并发秒杀优化（RabbitMQ+接口优化）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="font-weight: bold;">fanout模式</span>： <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 14pt; color: rgb(57, 57, 57); font-variant-caps: normal; font-variant-ligatures: normal;">fanout类型的Exchange会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中。</span></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><b><font style="font-size: 11pt;">MQConfig:</font></b></div><div>public static final String FANOUT_EXCHANGE = &quot;fanoutexchange&quot;;</div><div>@Bean</div><div>public FanoutExchange fanoutExchange(){</div><div>    return new FanoutExchange(FANOUT_EXCHANGE);</div><div>}</div><div><br/></div><div>@Bean</div><div>public Binding fanoutBinding1(){</div><div>    return BindingBuilder.bind(topicQueue1()).to(fanoutExchange());</div><div>}</div><div><br/></div><div>@Bean</div><div>public Binding fanoutBinding2(){</div><div>    return BindingBuilder.bind(topicQueue2()).to(fanoutExchange());</div><div>}</div><div><br/></div><div><br/></div><div><b><font style="font-size: 11pt;">MQSender:</font></b></div><div>public void fanoutSend(Object mm){</div><div>    String msg = RedisService.beanToString(mm);</div><div>    log.info(&quot;FANOUT send message:&quot;+msg);</div><div>    amqpTemplate.convertAndSend(MQConfig.FANOUT_EXCHANGE, &quot;&quot;, msg);</div><div>}</div><div><br/></div><div><b><font style="font-size: 11pt;">MQReceiver:</font></b></div><div>@RabbitListener(queues=MQConfig.TOPIC_QUEUE1)</div><div>public void fanoutReceive1(String msg){</div><div>    log.info(&quot;Fanout_QUEUE1 message:&quot;+msg);</div><div>}</div><div><br/></div><div><br/></div><div>@RabbitListener(queues=MQConfig.TOPIC_QUEUE2)</div><div>public void fanoutReceive2(String msg){</div><div>    log.info(&quot;Fanout_QUEUE2 message:&quot;+msg);</div><div>}</div></div><div><br/></div><div>结果：<img src="第6章 服务级高并发秒杀优化（RabbitMQ+接口优化）_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="font-weight: bold;">headers模式:</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="background-color: rgb(250, 247, 239);"><span style="text-indent: 0px;"><span style="background-color: rgb(250, 247, 239); font-size: 14pt; color: rgb(57, 57, 57); font-variant-caps: normal; font-variant-ligatures: normal;">headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue</span></span></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><b><font style="font-size: 11pt;">MQConfig:</font></b></div><div>public static final String HEADERS_QUEUE = &quot;headersqueue&quot;;</div><div>public static final String HEADERS_EXCHANGE = &quot;headerexchange&quot;;</div><div><br/></div><div>@Bean</div><div>public Queue headersQueue(){</div><div>    return new Queue(HEADERS_QUEUE, true);</div><div>}</div><div><br/></div><div>@Bean</div><div>public HeadersExchange headersExchange(){</div><div>    return new HeadersExchange(HEADERS_EXCHANGE);</div><div>}</div><div><br/></div><div>@Bean</div><div>public Binding headersBinding(){</div><div>    Map map = new HashMap&lt;String, Object&gt;();</div><div>    map.put(&quot;header1&quot;, &quot;value1&quot;);</div><div>    map.put(&quot;header2&quot;, &quot;value2&quot;);</div><div>    return BindingBuilder.bind(headersQueue()).to(headersExchange()).whereAll(map).match();</div><div>}</div><div><br/></div><div><b><font style="font-size: 11pt;">MQSender：</font></b></div><div>public void headerSend(Object mm){</div><div>    String msg = RedisService.beanToString(mm);</div><div>    log.info(&quot;HEADER send message:&quot;+msg);</div><div>    MessageProperties properties = new MessageProperties();</div><div>    properties.setHeader(&quot;header1&quot;, &quot;value1&quot;);</div><div>    properties.setHeader(&quot;header2&quot;, &quot;value2&quot;);</div><div>    Message message = new Message(msg.getBytes(), properties);</div><div>    amqpTemplate.convertAndSend(MQConfig.HEADERS_EXCHANGE, &quot;&quot;, message);</div><div>}</div><div><br/></div><div><b><font style="font-size: 11pt;">MQReceiver：</font></b></div><div>@RabbitListener(queues=MQConfig.HEADERS_QUEUE)</div><div>public void headersReceive(String msg){</div><div>    log.info(&quot;HEADERS_QUEUE message:&quot;+msg);</div><div>}</div><div><br/></div><div><b><font style="font-size: 11pt;">SampleController：</font></b></div><div>@ResponseBody</div><div>@RequestMapping(&quot;/mq/headers&quot;)</div><div>public Result&lt;String&gt; mqHeaders(){</div><div>    mqSender.headerSend(&quot;hello,mq&quot;);</div><div>    return Result.success(&quot;ok&quot;);</div><div>}</div></div><div>结果：<img src="第6章 服务级高并发秒杀优化（RabbitMQ+接口优化）_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 24pt; font-weight: bold;">三、秒杀接口优化</span></div></div><hr/><div>1）减少数据库的访问，在一定程度上尽量使用Redis</div><ul><li><div>    先实现 <span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">InitializingBean</span> <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="color: rgb(51, 51, 51); font-variant-caps: normal; font-variant-ligatures: normal; font-size: 14pt;">接口，做系统的初始化工作的时候获取产品列表。遍历每一项产品，将其Id和数量存入到redis中。在查询是否有剩余的时候不去查询数据库，而是查询redis，预减1，判断是否小于0，以此来判断是否有剩余</span></span></div></li><li><div><span style="color: rgb(51, 51, 51);">在做秒杀操作（数据库减库存、创建订单和秒杀订单）的时候，由原来直接操作，改为加入消息队列。由消息队列来轮询做操作。</span></div></li></ul><div>2）不再直接执行秒杀操作，而是引入消息队列，先入队，然后等待做轮询，再秒杀</div><div><br/></div></div><div><br/></div></span>
</div></body></html> 